Version 3.3.2:

     This version fixes a bug in the constructor code for creating a
     bit vector from a text string.  The bug was triggered by
     character escapes in such strings.

Version 3.3.1:

    This is a minor upgrade to make the syntax of the API method
    declarations more uniform.  Previously, while most of the method
    names used underscores to connect multiple words, some used
    camelcasing.  Now all use underscores.  For backward
    compatibility, the old calls will continue to work.

Version 3.3:

    This version includes: (1) One additional constructor mode that
    allows a bit vector to be constructed directly from the bytes
    type objects in the memory. (2) A bugfix in the slice function
    for the case when the upper and the lower bounds of the slice
    range are identical. (3) A bugfix for the next_set_bit() method.

Version 3.2:

    This version includes support for constructing bit vectors
    directly from text strings and hex strings.  This version also
    includes a safety check on the sizes of the two argument bit
    vectors when calculating Jaccard similarity between the two.

Version 3.1.1:

    This version includes: (1) a fix to the module test code to
    account for how string input is handled in the io.StringIO class
    in Python 2.7; (2) some improvements to the documentation.

Version 3.1:

    This version includes: (1) Correction for a documentation error;
    (2) Fix for a bug in slice assignment when one or both of the
    slice limits were left unspecified; (3) The non-circular bit
    shift methods now return self so that they can be chained; (4) A
    method for testing a bitvector for its primality; and (5) A
    method that uses Python's 'random.getrandbits()' to generate
    a bitvector that can serve as candidate for primes whose bitfield
    size is specified.

Version 3.0:

    This is a Python 3.x compliant version of the latest incarnation
    of the BitVector module.  This version should work with both
    Python 2.x and Python 3.x.

Version 2.2:

    Fixed a couple of bugs, the most important being in the
    bitvector initialization code for the cases when the
    user-specified value for size conflicts with the user-specified
    int value for the vector.  Version 2.2 also includes a new
    method runs() that returns a list of strings of the consecutive
    runs of 1's and 0's in the bitvector.  The implementation of
    the circular shift operators has also been improved in Version
    2.2. This version allows for a chained invocation of these
    operators.  Additionally, the circular shift operators now
    exhibit expected behavior if the user-specified shift value is
    negative.

Version 2.1:

    Includes enhanced support for folks who use this class for
    computer security and cryptography work.  You can now call on
    the methods of the BitVector class to do Galois Field GF(2^n)
    arithmetic on bit arrays.  This should save the users of this
    class the bother of having to write their own routines for
    finding multiplicative inverses in GF(2^n) finite fields.

Version 2.0.1:

    Fixed numerous typos and other errors in the documentation page
    for the module.  The implementation code remains unchanged.

Version 2.0:

    To address the needs of the folks who are using the BitVector
    class in data mining research, the new version of the class
    includes several additional methods.  Since the bitvectors used
    by these folks can be extremely long, possibly involving
    millions of bits, the new version of the class includes a much
    faster method for counting the total number of set bits when a
    bitvector is sparse.  [But note that this new bit counting
    method may perform poorly for dense bitvectors. So the old bit
    counting method has been retained.]  Also for data mining folks,
    the new version of the class is provided with similarity and
    distance calculation metrics such as the Jaccard similarity
    coefficient, the Jaccard distance, and the Hamming distance.
    Again for the same folks, the class now also has a
    next_set_bit(from_index) method.  Other enhancements to the
    class include methods for folks who do research in cryptography.
    Now you can directly calculate the greatest common divisor of
    two bitvectors, or find the multiplicative inverse of one
    bitvector modulo another bitvector.

Version 1.5.1:

    Removed a bug from the implementation of the right circular
    shift operator.

Version 1.5:

    This version should prove to be much more efficient for long
    bitvectors.  Efficiency in BitVector construction when only its
    size is specified was achieved by eliminating calls to
    _setbit().  The application of logical operators to two
    BitVectors of equal length was also made efficient by
    eliminating calls to the padding function.  Another feature of
    this version is the count_bits() method that returns the total
    number of bits set in a BitVector instance.  Yet another feature
    of this version is the setValue() method that alters the bit
    pattern associated with a previously constructed BitVector.

Version 1.4.1:

    The reset() method now returns 'self' to allow for cascaded
    invocation with the slicing operator.  Also removed the
    discrepancy between the value of the __copyright__ variable in
    the module and the value of license variable in setup.py.

Version 1.4:

    This version includes the following two upgrades: 1) code for
    slice assignment; and 2) A reset function to reinitialize a
    previously constructed BitVector.  Additionally, the code was
    cleaned up with the help of pychecker.

Version 1.3.2:

    Fixed a potentially misleading documentation issue for the
    Windows users of the BitVector class.  If you are writing an
    internally generated BitVector to a disk file, you must open the
    file in the binary mode.  If you don't, the bit patterns that
    correspond to line breaks will be misinterpreted.  On a Windows
    machine in the text mode, the bit pattern 000001010 ('\\n') will
    be written out to the disk as 0000110100001010 ('\\r\\n').

Version 1.3.1:

    Removed the inconsistency in the internal representation of
    bitvectors produced by logical bitwise operations vis-a-vis the
    bitvectors created by the constructor.  Previously, the logical
    bitwise operations resulted in bitvectors that had their bits
    packed into lists of ints, as opposed to arrays of unsigned
    shorts.

Version 1.3:

    (a) One more constructor mode included: When initializing a new
    bitvector with an integer value, you can now also specify a size
    for the bitvector.  The constructor zero-pads the bitvector
    from the left with zeros. (b) The BitVector class now supports
    'if x in y' syntax to test if the bit pattern 'x' is contained
    in the bit pattern 'y'.  (c) Improved syntax to conform to
    well-established Python idioms. (d) What used to be a comment
    before the beginning of each method definition is now a
    docstring.

Version 1.2:

    (a) One more constructor mode included: You can now construct a
    bitvector directly from a string of 1's and 0's.  (b) The class
    now constructs a shortest possible bit vector from an integer
    value.  So the bit vector for the integer value 0 is just one
    bit of value 0, and so on. (c) All the rich comparison operators
    are now overloaded. (d) The class now includes a new method
    'intValue()' that returns the unsigned integer value of a bit
    vector.  This can also be done through '__int__'. (e) The
    package now includes a unittest based framework for testing out
    an installation.  This is in a separate directory called
    "TestBitVector".

Version 1.1.1:

    The function that does block reads from a disk file now peeks
    ahead at the end of each block to see if there is anything
    remaining to be read in the file.  If nothing remains, the
    more_to_read attribute of the BitVector object is set to False.
    This simplifies reading loops. This version also allows
    BitVectors of size 0 to be constructed


Version 1.1:

    I have changed the API significantly to provide more ways for
    constructing a bit vector.  As a result, it is now necessary to
    supply a keyword argument to the constructor.
